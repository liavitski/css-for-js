{"ast":null,"code":"var $buum9$babelruntimehelpersextends = require(\"@babel/runtime/helpers/extends\");\nvar $buum9$react = require(\"react\");\nvar $buum9$radixuireactcomposerefs = require(\"@radix-ui/react-compose-refs\");\nvar $buum9$radixuireactprimitive = require(\"@radix-ui/react-primitive\");\nvar $buum9$radixuireactusecallbackref = require(\"@radix-ui/react-use-callback-ref\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n$parcel$export(module.exports, \"FocusScope\", () => $2bc01e66e04aa9ed$export$20e40289641fbbb6);\n$parcel$export(module.exports, \"Root\", () => $2bc01e66e04aa9ed$export$be92b6f5f03c0fe9);\nconst $2bc01e66e04aa9ed$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst $2bc01e66e04aa9ed$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst $2bc01e66e04aa9ed$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\nconst $2bc01e66e04aa9ed$var$FOCUS_SCOPE_NAME = 'FocusScope';\nconst $2bc01e66e04aa9ed$export$20e40289641fbbb6 = /*#__PURE__*/$buum9$react.forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container1, setContainer] = $buum9$react.useState(null);\n  const onMountAutoFocus = $buum9$radixuireactusecallbackref.useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = $buum9$radixuireactusecallbackref.useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = $buum9$react.useRef(null);\n  const composedRefs = $buum9$radixuireactcomposerefs.useComposedRefs(forwardedRef, node => setContainer(node));\n  const focusScope = $buum9$react.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current; // Takes care of trapping focus if focus is moved outside programmatically for example\n  $buum9$react.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event) {\n        if (focusScope.paused || !container1) return;\n        const target = event.target;\n        if (container1.contains(target)) lastFocusedElementRef.current = target;else $2bc01e66e04aa9ed$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      }\n      function handleFocusOut(event) {\n        if (focusScope.paused || !container1) return;\n        const relatedTarget = event.relatedTarget; // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return; // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container1.contains(relatedTarget)) $2bc01e66e04aa9ed$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      } // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations) {\n        const focusedElement = document.activeElement;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) if (mutation.removedNodes.length > 0) $2bc01e66e04aa9ed$var$focus(container1);\n      }\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container1) mutationObserver.observe(container1, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container1, focusScope.paused]);\n  $buum9$react.useEffect(() => {\n    if (container1) {\n      $2bc01e66e04aa9ed$var$focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_MOUNT, $2bc01e66e04aa9ed$var$EVENT_OPTIONS);\n        container1.addEventListener($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container1.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          $2bc01e66e04aa9ed$var$focusFirst($2bc01e66e04aa9ed$var$removeLinks($2bc01e66e04aa9ed$var$getTabbableCandidates(container1)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement) $2bc01e66e04aa9ed$var$focus(container1);\n        }\n      }\n      return () => {\n        container1.removeEventListener($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_UNMOUNT, $2bc01e66e04aa9ed$var$EVENT_OPTIONS);\n          container1.addEventListener($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container1.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) $2bc01e66e04aa9ed$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n            select: true\n          });\n          // we need to remove the listener after we `dispatchEvent`\n          container1.removeEventListener($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          $2bc01e66e04aa9ed$var$focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container1, onMountAutoFocus, onUnmountAutoFocus, focusScope]); // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = $buum9$react.useCallback(event => {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n    if (isTabKey && focusedElement) {\n      const container = event.currentTarget;\n      const [first, last] = $2bc01e66e04aa9ed$var$getTabbableEdges(container);\n      const hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) $2bc01e66e04aa9ed$var$focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) $2bc01e66e04aa9ed$var$focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /*#__PURE__*/$buum9$react.createElement($buum9$radixuireactprimitive.Primitive.div, $parcel$interopDefault($buum9$babelruntimehelpersextends)({\n    tabIndex: -1\n  }, scopeProps, {\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  }));\n});\n/*#__PURE__*/\nObject.assign($2bc01e66e04aa9ed$export$20e40289641fbbb6, {\n  displayName: $2bc01e66e04aa9ed$var$FOCUS_SCOPE_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/ /**\n                                                                                                     * Attempts focusing the first element in a list of candidates.\n                                                                                                     * Stops when focus has actually moved.\n                                                                                                     */\nfunction $2bc01e66e04aa9ed$var$focusFirst(candidates, {\n  select = false\n} = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    $2bc01e66e04aa9ed$var$focus(candidate, {\n      select: select\n    });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction $2bc01e66e04aa9ed$var$getTabbableEdges(container) {\n  const candidates = $2bc01e66e04aa9ed$var$getTabbableCandidates(container);\n  const first = $2bc01e66e04aa9ed$var$findVisible(candidates, container);\n  const last = $2bc01e66e04aa9ed$var$findVisible(candidates.reverse(), container);\n  return [first, last];\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction $2bc01e66e04aa9ed$var$getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction $2bc01e66e04aa9ed$var$findVisible(elements, container) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!$2bc01e66e04aa9ed$var$isHidden(element, {\n      upTo: container\n    })) return element;\n  }\n}\nfunction $2bc01e66e04aa9ed$var$isHidden(node, {\n  upTo: upTo\n}) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction $2bc01e66e04aa9ed$var$isSelectableInput(element) {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\nfunction $2bc01e66e04aa9ed$var$focus(element, {\n  select = false\n} = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({\n      preventScroll: true\n    }); // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && $2bc01e66e04aa9ed$var$isSelectableInput(element) && select) element.select();\n  }\n}\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\nconst $2bc01e66e04aa9ed$var$focusScopesStack = $2bc01e66e04aa9ed$var$createFocusScopesStack();\nfunction $2bc01e66e04aa9ed$var$createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */let stack = [];\n  return {\n    add(focusScope) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = $2bc01e66e04aa9ed$var$arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      var _stack$;\n      stack = $2bc01e66e04aa9ed$var$arrayRemove(stack, focusScope);\n      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n    }\n  };\n}\nfunction $2bc01e66e04aa9ed$var$arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) updatedArray.splice(index, 1);\n  return updatedArray;\n}\nfunction $2bc01e66e04aa9ed$var$removeLinks(items) {\n  return items.filter(item => item.tagName !== 'A');\n}\nconst $2bc01e66e04aa9ed$export$be92b6f5f03c0fe9 = $2bc01e66e04aa9ed$export$20e40289641fbbb6;","map":{"version":3,"names":["$2bc01e66e04aa9ed$var$AUTOFOCUS_ON_MOUNT","$2bc01e66e04aa9ed$var$AUTOFOCUS_ON_UNMOUNT","$2bc01e66e04aa9ed$var$EVENT_OPTIONS","bubbles","cancelable","$2bc01e66e04aa9ed$var$FOCUS_SCOPE_NAME","$2bc01e66e04aa9ed$export$20e40289641fbbb6","$buum9$react","forwardRef","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container1","setContainer","useState","$buum9$radixuireactusecallbackref","useCallbackRef","lastFocusedElementRef","useRef","composedRefs","$buum9$radixuireactcomposerefs","useComposedRefs","node","focusScope","paused","pause","resume","current","useEffect","handleFocusIn","event","target","contains","$2bc01e66e04aa9ed$var$focus","select","handleFocusOut","relatedTarget","handleMutations","mutations","focusedElement","document","activeElement","body","mutation","removedNodes","length","addEventListener","mutationObserver","MutationObserver","observe","childList","subtree","removeEventListener","disconnect","$2bc01e66e04aa9ed$var$focusScopesStack","add","previouslyFocusedElement","hasFocusedCandidate","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","$2bc01e66e04aa9ed$var$focusFirst","$2bc01e66e04aa9ed$var$removeLinks","$2bc01e66e04aa9ed$var$getTabbableCandidates","setTimeout","unmountEvent","remove","handleKeyDown","useCallback","isTabKey","key","altKey","ctrlKey","metaKey","container","currentTarget","first","last","$2bc01e66e04aa9ed$var$getTabbableEdges","hasTabbableElementsInside","preventDefault","shiftKey","createElement","$buum9$radixuireactprimitive","Primitive","div","$parcel$interopDefault","$buum9$babelruntimehelpersextends","tabIndex","ref","onKeyDown","Object","assign","displayName","focusFirst","candidates","candidate","getTabbableEdges","$2bc01e66e04aa9ed$var$findVisible","reverse","getTabbableCandidates","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","findVisible","elements","element","$2bc01e66e04aa9ed$var$isHidden","upTo","isHidden","getComputedStyle","visibility","undefined","display","parentElement","$2bc01e66e04aa9ed$var$isSelectableInput","isSelectableInput","HTMLInputElement","focus","preventScroll","$2bc01e66e04aa9ed$var$createFocusScopesStack","createFocusScopesStack","stack","activeFocusScope","$2bc01e66e04aa9ed$var$arrayRemove","unshift","_stack$","arrayRemove","array","item","updatedArray","index","indexOf","splice","removeLinks","items","filter","$2bc01e66e04aa9ed$export$be92b6f5f03c0fe9"],"sources":["packages/react/focus-scope/src/index.ts","packages/react/focus-scope/src/FocusScope.tsx"],"sourcesContent":["export {\n  FocusScope,\n  //\n  Root,\n} from './FocusScope';\nexport type { FocusScopeProps } from './FocusScope';\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget as HTMLElement | null;\n\n        // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return;\n\n        // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations: MutationRecord[]) {\n        const focusedElement = document.activeElement as HTMLElement | null;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}