{"ast":null,"code":"var $buum9$babelruntimehelpersextends = require(\"@babel/runtime/helpers/extends\");\n\nvar $buum9$react = require(\"react\");\n\nvar $buum9$radixuireactcomposerefs = require(\"@radix-ui/react-compose-refs\");\n\nvar $buum9$radixuireactprimitive = require(\"@radix-ui/react-primitive\");\n\nvar $buum9$radixuireactusecallbackref = require(\"@radix-ui/react-use-callback-ref\");\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n$parcel$export(module.exports, \"FocusScope\", () => $2bc01e66e04aa9ed$export$20e40289641fbbb6);\n$parcel$export(module.exports, \"Root\", () => $2bc01e66e04aa9ed$export$be92b6f5f03c0fe9);\nconst $2bc01e66e04aa9ed$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst $2bc01e66e04aa9ed$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst $2bc01e66e04aa9ed$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst $2bc01e66e04aa9ed$var$FOCUS_SCOPE_NAME = 'FocusScope';\nconst $2bc01e66e04aa9ed$export$20e40289641fbbb6 = /*#__PURE__*/$buum9$react.forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container1, setContainer] = $buum9$react.useState(null);\n  const onMountAutoFocus = $buum9$radixuireactusecallbackref.useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = $buum9$radixuireactusecallbackref.useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = $buum9$react.useRef(null);\n  const composedRefs = $buum9$radixuireactcomposerefs.useComposedRefs(forwardedRef, node => setContainer(node));\n  const focusScope = $buum9$react.useRef({\n    paused: false,\n\n    pause() {\n      this.paused = true;\n    },\n\n    resume() {\n      this.paused = false;\n    }\n\n  }).current; // Takes care of trapping focus if focus is moved outside programmatically for example\n\n  $buum9$react.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event) {\n        if (focusScope.paused || !container1) return;\n        const target = event.target;\n        if (container1.contains(target)) lastFocusedElementRef.current = target;else $2bc01e66e04aa9ed$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      }\n\n      function handleFocusOut(event) {\n        if (focusScope.paused || !container1) return;\n        const relatedTarget = event.relatedTarget; // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n\n        if (relatedTarget === null) return; // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n\n        if (!container1.contains(relatedTarget)) $2bc01e66e04aa9ed$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      } // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n\n\n      function handleMutations(mutations) {\n        const focusedElement = document.activeElement;\n        if (focusedElement !== document.body) return;\n\n        for (const mutation of mutations) if (mutation.removedNodes.length > 0) $2bc01e66e04aa9ed$var$focus(container1);\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container1) mutationObserver.observe(container1, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container1, focusScope.paused]);\n  $buum9$react.useEffect(() => {\n    if (container1) {\n      $2bc01e66e04aa9ed$var$focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_MOUNT, $2bc01e66e04aa9ed$var$EVENT_OPTIONS);\n        container1.addEventListener($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container1.dispatchEvent(mountEvent);\n\n        if (!mountEvent.defaultPrevented) {\n          $2bc01e66e04aa9ed$var$focusFirst($2bc01e66e04aa9ed$var$removeLinks($2bc01e66e04aa9ed$var$getTabbableCandidates(container1)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement) $2bc01e66e04aa9ed$var$focus(container1);\n        }\n      }\n\n      return () => {\n        container1.removeEventListener($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_UNMOUNT, $2bc01e66e04aa9ed$var$EVENT_OPTIONS);\n          container1.addEventListener($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container1.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) $2bc01e66e04aa9ed$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n            select: true\n          }); // we need to remove the listener after we `dispatchEvent`\n\n          container1.removeEventListener($2bc01e66e04aa9ed$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          $2bc01e66e04aa9ed$var$focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container1, onMountAutoFocus, onUnmountAutoFocus, focusScope]); // Takes care of looping focus (when tabbing whilst at the edges)\n\n  const handleKeyDown = $buum9$react.useCallback(event => {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n\n    if (isTabKey && focusedElement) {\n      const container = event.currentTarget;\n      const [first, last] = $2bc01e66e04aa9ed$var$getTabbableEdges(container);\n      const hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges\n\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) $2bc01e66e04aa9ed$var$focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) $2bc01e66e04aa9ed$var$focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /*#__PURE__*/$buum9$react.createElement($buum9$radixuireactprimitive.Primitive.div, $parcel$interopDefault($buum9$babelruntimehelpersextends)({\n    tabIndex: -1\n  }, scopeProps, {\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  }));\n});\n/*#__PURE__*/\n\nObject.assign($2bc01e66e04aa9ed$export$20e40289641fbbb6, {\n  displayName: $2bc01e66e04aa9ed$var$FOCUS_SCOPE_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n* Attempts focusing the first element in a list of candidates.\n* Stops when focus has actually moved.\n*/\n\nfunction $2bc01e66e04aa9ed$var$focusFirst(candidates, {\n  select = false\n} = {}) {\n  const previouslyFocusedElement = document.activeElement;\n\n  for (const candidate of candidates) {\n    $2bc01e66e04aa9ed$var$focus(candidate, {\n      select: select\n    });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n/**\n * Returns the first and last tabbable elements inside a container.\n */\n\n\nfunction $2bc01e66e04aa9ed$var$getTabbableEdges(container) {\n  const candidates = $2bc01e66e04aa9ed$var$getTabbableCandidates(container);\n  const first = $2bc01e66e04aa9ed$var$findVisible(candidates, container);\n  const last = $2bc01e66e04aa9ed$var$findVisible(candidates.reverse(), container);\n  return [first, last];\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\n\n\nfunction $2bc01e66e04aa9ed$var$getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  while (walker.nextNode()) nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n\n\n  return nodes;\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\n\n\nfunction $2bc01e66e04aa9ed$var$findVisible(elements, container) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!$2bc01e66e04aa9ed$var$isHidden(element, {\n      upTo: container\n    })) return element;\n  }\n}\n\nfunction $2bc01e66e04aa9ed$var$isHidden(node, {\n  upTo: upTo\n}) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n\n  return false;\n}\n\nfunction $2bc01e66e04aa9ed$var$isSelectableInput(element) {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction $2bc01e66e04aa9ed$var$focus(element, {\n  select = false\n} = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n\n    element.focus({\n      preventScroll: true\n    }); // only select if its not the same element, it supports selection and we need to select\n\n    if (element !== previouslyFocusedElement && $2bc01e66e04aa9ed$var$isSelectableInput(element) && select) element.select();\n  }\n}\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\n\nconst $2bc01e66e04aa9ed$var$focusScopesStack = $2bc01e66e04aa9ed$var$createFocusScopesStack();\n\nfunction $2bc01e66e04aa9ed$var$createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack = [];\n  return {\n    add(focusScope) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause(); // remove in case it already exists (because we'll re-add it at the top of the stack)\n\n      stack = $2bc01e66e04aa9ed$var$arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope) {\n      var _stack$;\n\n      stack = $2bc01e66e04aa9ed$var$arrayRemove(stack, focusScope);\n      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n    }\n\n  };\n}\n\nfunction $2bc01e66e04aa9ed$var$arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) updatedArray.splice(index, 1);\n  return updatedArray;\n}\n\nfunction $2bc01e66e04aa9ed$var$removeLinks(items) {\n  return items.filter(item => item.tagName !== 'A');\n}\n\nconst $2bc01e66e04aa9ed$export$be92b6f5f03c0fe9 = $2bc01e66e04aa9ed$export$20e40289641fbbb6;","map":{"version":3,"sources":["packages/react/focus-scope/src/FocusScope.tsx"],"names":["AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_UNMOUNT","EVENT_OPTIONS","bubbles","cancelable","FOCUS_SCOPE_NAME","FocusScope","loop","trapped","onMountAutoFocus","onUnmountAutoFocus","React","useCallbackRef","lastFocusedElementRef","composedRefs","useComposedRefs","node","setContainer","focusScope","paused","pause","resume","target","event","container","select","relatedTarget","focusedElement","document","mutation","focus","mutationObserver","childList","subtree","focusScopesStack","previouslyFocusedElement","hasFocusedCandidate","mountEvent","focusFirst","removeLinks","getTabbableCandidates","setTimeout","unmountEvent","handleKeyDown","isTabKey","getTabbableEdges","hasTabbableElementsInside","first","candidates","findVisible","last","nodes","walker","NodeFilter","acceptNode","isHiddenInput","isHidden","upTo","getComputedStyle","element","preventScroll","isSelectableInput","createFocusScopesStack","stack","add","activeFocusScope","arrayRemove","remove","updatedArray","index","item","Root"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAOA,MAAMA,wCAAkB,GAAxB,6BAAA;AACA,MAAMC,0CAAoB,GAA1B,+BAAA;AACA,MAAMC,mCAAa,GAAG;AAAEC,EAAAA,OAAO,EAAT,KAAA;AAAkBC,EAAAA,UAAU,EAAVA;AAAlB,CAAtB;AAIA;;AAEA;;AAEA,MAAMC,sCAAgB,GAAtB,YAAA;AAgCA,MAAMC,yCAAU,GAAA,aAAG,YAAA,CAAA,UAAA,CAAqD,CAAA,KAAA,EAAA,YAAA,KAAyB;AAC/F,QAAM;AACJC,IAAAA,IAAI,GADA,KAAA;AAEJC,IAAAA,OAAO,GAFH,KAAA;AAGJC,IAAAA,gBAAgB,EAHZ,oBAAA;AAIJC,IAAAA,kBAAkB,EAJd,sBAAA;AAKJ,OALI;AAAA,MAAN,KAAA;AAOA,QAAM,CAAA,UAAA,EAAA,YAAA,IAA4BC,YAAAA,CAAAA,QAAAA,CAAlC,IAAkCA,CAAlC;AACA,QAAMF,gBAAgB,GAAGG,iCAAAA,CAAAA,cAAAA,CAAzB,oBAAyBA,CAAzB;AACA,QAAMF,kBAAkB,GAAGE,iCAAAA,CAAAA,cAAAA,CAA3B,sBAA2BA,CAA3B;AACA,QAAMC,qBAAqB,GAAGF,YAAAA,CAAAA,MAAAA,CAA9B,IAA8BA,CAA9B;AACA,QAAMG,YAAY,GAAGC,8BAAAA,CAAAA,eAAAA,CAAe,YAAfA,EAA8B,IAACC,IAASC,YAAY,CAArC,IAAqC,CAApDF,CAArB;AAEA,QAAMG,UAAU,GAAG,YAAA,CAAA,MAAA,CAAa;AAC9BC,IAAAA,MAAM,EADwB,KAAA;;AAE9BC,IAAAA,KAAK,GAAG;AACN,WAAA,MAAA,GAAA,IAAA;AAH4B,KAAA;;AAK9BC,IAAAA,MAAM,GAAG;AACP,WAAA,MAAA,GAAA,KAAA;AACD;;AAP6B,GAAb,EAd4E,OAc/F,CAd+F,CAc/D;;AAWhCV,EAAAA,YAAAA,CAAAA,SAAAA,CAAgB,MAAM;AACpB,QAAA,OAAA,EAAa;AACX,eAAA,aAAA,CAAA,KAAA,EAA0C;AACxC,YAAIO,UAAU,CAAVA,MAAAA,IAAqB,CAAzB,UAAA,EAAA;AACA,cAAMI,MAAM,GAAGC,KAAK,CAApB,MAAA;AACA,YAAIC,UAAS,CAATA,QAAAA,CAAJ,MAAIA,CAAJ,EACEX,qBAAqB,CAArBA,OAAAA,GAAAA,MAAAA,CADF,KAGE,2BAAK,CAACA,qBAAqB,CAAtB,OAAA,EAAgC;AAAEY,UAAAA,MAAM,EAANA;AAAF,SAAhC,CAAL;AAEH;;AAED,eAAA,cAAA,CAAA,KAAA,EAA2C;AACzC,YAAIP,UAAU,CAAVA,MAAAA,IAAqB,CAAzB,UAAA,EAAA;AACA,cAAMQ,aAAa,GAAGH,KAAK,CAFc,aAEzC,CAFyC,CAEzC;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAIG,aAAa,KAAjB,IAAA,EAdyC,OAAA,CAczC;AAGA;;AACA,YAAI,CAACF,UAAS,CAATA,QAAAA,CAAL,aAAKA,CAAL,EACE,2BAAK,CAACX,qBAAqB,CAAtB,OAAA,EAAgC;AAAEY,UAAAA,MAAM,EAANA;AAAF,SAAhC,CAAL;AA9BO,OAAA,CAgCV;AAGD;AACA;;;AACA,eAAA,eAAA,CAAA,SAAA,EAAsD;AACpD,cAAME,cAAc,GAAGC,QAAQ,CAA/B,aAAA;AACA,YAAID,cAAc,KAAKC,QAAQ,CAA/B,IAAA,EAAA;;AACA,aAAK,MAAL,QAAA,IAAA,SAAA,EACE,IAAIC,QAAQ,CAARA,YAAAA,CAAAA,MAAAA,GAAJ,CAAA,EAAsCC,2BAAK,CAA3C,UAA2C,CAALA;AAEzC;;AAEDF,MAAAA,QAAQ,CAARA,gBAAAA,CAAAA,SAAAA,EAAAA,aAAAA;AACAA,MAAAA,QAAQ,CAARA,gBAAAA,CAAAA,UAAAA,EAAAA,cAAAA;AACA,YAAMG,gBAAgB,GAAG,IAAA,gBAAA,CAAzB,eAAyB,CAAzB;AACA,UAAA,UAAA,EAAe,gBAAgB,CAAhB,OAAA,CAAA,UAAA,EAAoC;AAAEC,QAAAA,SAAS,EAAX,IAAA;AAAmBC,QAAAA,OAAO,EAAPA;AAAnB,OAApC;AAEf,aAAO,MAAM;AACXL,QAAAA,QAAQ,CAARA,mBAAAA,CAAAA,SAAAA,EAAAA,aAAAA;AACAA,QAAAA,QAAQ,CAARA,mBAAAA,CAAAA,UAAAA,EAAAA,cAAAA;AACAG,QAAAA,gBAAgB,CAAhBA,UAAAA;AAHF,OAAA;AAKD;AAxDHpB,GAAAA,EAyDG,CAAA,OAAA,EAAA,UAAA,EAAqBO,UAAU,CAA/B,MAAA,CAzDHP;AA2DAA,EAAAA,YAAAA,CAAAA,SAAAA,CAAgB,MAAM;AACpB,QAAA,UAAA,EAAe;AACbuB,MAAAA,sCAAgB,CAAhBA,GAAAA,CAAAA,UAAAA;AACA,YAAMC,wBAAwB,GAAGP,QAAQ,CAAzC,aAAA;AACA,YAAMQ,mBAAmB,GAAGZ,UAAS,CAATA,QAAAA,CAA5B,wBAA4BA,CAA5B;;AAEA,UAAI,CAAJ,mBAAA,EAA0B;AACxB,cAAMa,UAAU,GAAG,IAAA,WAAA,CAAA,wCAAA,EAAnB,mCAAmB,CAAnB;AACAb,QAAAA,UAAS,CAATA,gBAAAA,CAAAA,wCAAAA,EAAAA,gBAAAA;AACAA,QAAAA,UAAS,CAATA,aAAAA,CAAAA,UAAAA;;AACA,YAAI,CAACa,UAAU,CAAf,gBAAA,EAAkC;AAChCC,UAAAA,gCAAU,CAACC,iCAAW,CAACC,2CAAqB,CAAlC,UAAkC,CAAtB,CAAZ,EAAgD;AAAEf,YAAAA,MAAM,EAANA;AAAF,WAAhD,CAAVa;AACA,cAAIV,QAAQ,CAARA,aAAAA,KAAJ,wBAAA,EACEE,2BAAK,CAALA,UAAK,CAALA;AAEH;AACF;;AAED,aAAO,MAAM;AACXN,QAAAA,UAAS,CAATA,mBAAAA,CAAAA,wCAAAA,EADW,gBACXA,EADW,CACXA;AAGA;AACA;;AACAiB,QAAAA,UAAU,CAAC,MAAM;AACf,gBAAMC,YAAY,GAAG,IAAA,WAAA,CAAA,0CAAA,EAArB,mCAAqB,CAArB;AACAlB,UAAAA,UAAS,CAATA,gBAAAA,CAAAA,0CAAAA,EAAAA,kBAAAA;AACAA,UAAAA,UAAS,CAATA,aAAAA,CAAAA,YAAAA;AACA,cAAI,CAACkB,YAAY,CAAjB,gBAAA,EACE,2BAAK,CAACP,wBAAD,KAAA,IAACA,IAAAA,wBAAD,KAAA,KAAA,CAACA,GAAD,wBAACA,GAA4BP,QAAQ,CAArC,IAAA,EAA4C;AAAEH,YAAAA,MAAM,EAANA;AAAF,WAA5C,CAAL,CALa,CAMd;;AAEDD,UAAAA,UAAS,CAATA,mBAAAA,CAAAA,0CAAAA,EAAAA,kBAAAA;AAEAU,UAAAA,sCAAgB,CAAhBA,MAAAA,CAAAA,UAAAA;AAVQ,SAAA,EAAVO,CAAU,CAAVA;AANF,OAAA;AAmBD;AArCH9B,GAAAA,EAsCG,CAAA,UAAA,EAAA,gBAAA,EAAA,kBAAA,EAAA,UAAA,CAtCHA,EApF+F,CA0H9F;;AAGD,QAAMgC,aAAa,GAAG,YAAA,CAAA,WAAA,CACpB,KAACpB,IAA+B;AAC9B,QAAI,CAAA,IAAA,IAAS,CAAb,OAAA,EAAA;AACA,QAAIL,UAAU,CAAd,MAAA,EAAA;AAEA,UAAM0B,QAAQ,GAAGrB,KAAK,CAALA,GAAAA,KAAAA,KAAAA,IAAuB,CAACA,KAAK,CAA7BA,MAAAA,IAAwC,CAACA,KAAK,CAA9CA,OAAAA,IAA0D,CAACA,KAAK,CAAjF,OAAA;AACA,UAAMI,cAAc,GAAGC,QAAQ,CAA/B,aAAA;;AAEA,QAAIgB,QAAQ,IAAZ,cAAA,EAAgC;AAC9B,YAAMpB,SAAS,GAAGD,KAAK,CAAvB,aAAA;AACA,YAAM,CAAA,KAAA,EAAA,IAAA,IAAgBsB,sCAAgB,CAAtC,SAAsC,CAAtC;AACA,YAAMC,yBAAyB,GAAGC,KAAK,IAHT,IAG9B,CAH8B,CAG9B;;AAGA,UAAI,CAAJ,yBAAA,EACE;AAAA,YAAIpB,cAAc,KAAlB,SAAA,EAAkCJ,KAAK,CAAvC,cAAkCA;AAAlC,OADF,MAEO;AACL,YAAI,CAACA,KAAK,CAAN,QAAA,IAAmBI,cAAc,KAArC,IAAA,EAAgD;AAC9CJ,UAAAA,KAAK,CAALA,cAAAA;AACA,cAAA,IAAA,EAAU,2BAAK,CAAA,KAAA,EAAQ;AAAEE,YAAAA,MAAM,EAANA;AAAF,WAAR,CAAL;AAFZ,SAAA,MAGO,IAAIF,KAAK,CAALA,QAAAA,IAAkBI,cAAc,KAApC,KAAA,EAAgD;AACrDJ,UAAAA,KAAK,CAALA,cAAAA;AACA,cAAA,IAAA,EAAU,2BAAK,CAAA,IAAA,EAAO;AAAEE,YAAAA,MAAM,EAANA;AAAF,WAAP,CAAL;AACX;AACF;AACF;AAzBiB,GAAA,EA2BpB,CAAA,IAAA,EAAA,OAAA,EAAgBP,UAAU,CAA1B,MAAA,CA3BoB,CAAtB;AA8BA,SAAA,aACE,YAAA,CAAA,aAAA,CAAC,4BAAA,CAAD,SAAC,CAAD,GAAA,EADF,sBAAA,CAAA,iCAAA,CAAA,CAAA;AACiB,IAAA,QAAQ,EAAE,CAAV;AADjB,GAAA,EACE,UADF,EACE;AAA6C,IAAA,GAAG,EAAhD,YAAA;AAAgE,IAAA,SAAS,EAAT;AAAhE,GADF,CACE,CADF;AA3JF,CAAmB,CAAnB;AAgKA;;AAAA,MAAA,CAAA,MAAA,CAAA,yCAAA,EAAA;AAAA,EAAA,WAAA,EAAA;AAAA,CAAA;AAEA;;AAEA;;AAEA;;;AAGA;;AACA,SAAA,gCAAA,CAAA,UAAA,EAA+C;AAAEO,EAAAA,MAAM,GAAR;AAAA,IAA/C,EAAA,EAAwE;AACtE,QAAMU,wBAAwB,GAAGP,QAAQ,CAAzC,aAAA;;AACA,OAAK,MAAL,SAAA,IAAA,UAAA,EAAoC;AAClCE,IAAAA,2BAAK,CAAA,SAAA,EAAY;cAAEL;AAAF,KAAZ,CAALK;AACA,QAAIF,QAAQ,CAARA,aAAAA,KAAJ,wBAAA,EAAA;AACD;AACF;AAED;;AAEA;;;AACA,SAAA,sCAAA,CAAA,SAAA,EAAkD;AAChD,QAAMoB,UAAU,GAAGR,2CAAqB,CAAxC,SAAwC,CAAxC;AACA,QAAMO,KAAK,GAAGE,iCAAW,CAAA,UAAA,EAAzB,SAAyB,CAAzB;AACA,QAAMC,IAAI,GAAGD,iCAAW,CAACD,UAAU,CAAX,OAACA,EAAD,EAAxB,SAAwB,CAAxB;AACA,SAAO,CAAA,KAAA,EAAA,IAAA,CAAP;AACD;AAED;;;;;;;;;AASA;;;AACA,SAAA,2CAAA,CAAA,SAAA,EAAuD;AACrD,QAAMG,KAAoB,GAA1B,EAAA;AACA,QAAMC,MAAM,GAAG,QAAQ,CAAR,gBAAA,CAAA,SAAA,EAAqCC,UAAU,CAA/C,YAAA,EAA8D;AAC3EC,IAAAA,UAAU,EAAE,IAACtC,IAAc;AACzB,YAAMuC,aAAa,GAAGvC,IAAI,CAAJA,OAAAA,KAAAA,OAAAA,IAA4BA,IAAI,CAAJA,IAAAA,KAAlD,QAAA;AACA,UAAIA,IAAI,CAAJA,QAAAA,IAAiBA,IAAI,CAArBA,MAAAA,IAAJ,aAAA,EAAmD,OAAOqC,UAAU,CAF3C,WAE0B,CAF1B,CAEzB;AAEA;AACA;;AACA,aAAOrC,IAAI,CAAJA,QAAAA,IAAAA,CAAAA,GAAqBqC,UAAU,CAA/BrC,aAAAA,GAAgDqC,UAAU,CAAjE,WAAA;AACD;AAR0E,GAA9D,CAAf;;AAUA,SAAOD,MAAM,CAAb,QAAOA,EAAP,EAA0BD,KAAK,CAALA,IAAAA,CAAWC,MAAM,CAZU,WAY3BD,EAZ2B,CAYrD;AAEA;;;AACA,SAAA,KAAA;AACD;AAED;;;AAGA;;;AACA,SAAA,iCAAA,CAAA,QAAA,EAAA,SAAA,EAAsE;AACpE,OAAK,MAAL,OAAA,IAAA,QAAA,EAAgC;AAC9B;AACA,QAAI,CAACK,8BAAQ,CAAA,OAAA,EAAU;AAAEC,MAAAA,IAAI,EAAJA;AAAF,KAAV,CAAb,EAA6C,OAAtB,OAAsB;AAC9C;AACF;;AAED,SAAA,8BAAA,CAAA,IAAA,EAAqC;QAArC;AAAqC,CAArC,EAAuE;AACrE,MAAIC,gBAAgB,CAAhBA,IAAgB,CAAhBA,CAAAA,UAAAA,KAAJ,QAAA,EAAoD,OAApD,IAAoD;;AACpD,SAAA,IAAA,EAAa;AACX;AACA,QAAID,IAAI,KAAJA,SAAAA,IAAsBzC,IAAI,KAA9B,IAAA,EAAyC,OAAzC,KAAyC;AACzC,QAAI0C,gBAAgB,CAAhBA,IAAgB,CAAhBA,CAAAA,OAAAA,KAAJ,MAAA,EAA+C,OAA/C,IAA+C;AAC/C1C,IAAAA,IAAI,GAAGA,IAAI,CAAXA,aAAAA;AACD;;AACD,SAAA,KAAA;AACD;;AAED,SAAA,uCAAA,CAAA,OAAA,EAA8F;AAC5F,SAAO2C,OAAO,YAAPA,gBAAAA,IAAuC,YAA9C,OAAA;AACD;;AAED,SAAA,2BAAA,CAAA,OAAA,EAAiD;AAAElC,EAAAA,MAAM,GAAR;AAAA,IAAjD,EAAA,EAA0E;AACxE;AACA,MAAIkC,OAAO,IAAIA,OAAO,CAAtB,KAAA,EAA8B;AAC5B,UAAMxB,wBAAwB,GAAGP,QAAQ,CADb,aAC5B,CAD4B,CAC5B;;AAEA+B,IAAAA,OAAO,CAAPA,KAAAA,CAAc;AAAEC,MAAAA,aAAa,EAAbA;AAAF,KAAdD,EAH4B,CAGd;;AAEd,QAAIA,OAAO,KAAPA,wBAAAA,IAAwCE,uCAAiB,CAAzDF,OAAyD,CAAzDA,IAAJ,MAAA,EACEA,OAAO,CADT,MACEA;AACH;AACF;AAED;;AAEA;;;AAGA,MAAMzB,sCAAgB,GAAG4B,4CAAzB,EAAA;;AAEA,SAAA,4CAAA,GAAkC;AAChC;AACA,MAAIC,KAAsB,GAA1B,EAAA;AAEA,SAAO;AACLC,IAAAA,GAAG,CAAA,UAAA,EAA4B;AAC7B;AACA,YAAMC,gBAAgB,GAAGF,KAAK,CAA9B,CAA8B,CAA9B;AACA,UAAI7C,UAAU,KAAd,gBAAA,EACE+C,gBAAgB,KAAhBA,IAAAA,IAAAA,gBAAgB,KAAA,KAAhBA,CAAAA,IAAAA,gBAAgB,CAAhBA,KAAAA,EAAAA,CAJ2B,CAK5B;;AAEDF,MAAAA,KAAK,GAAGG,iCAAW,CAAA,KAAA,EAAnBH,UAAmB,CAAnBA;AACAA,MAAAA,KAAK,CAALA,OAAAA,CAAAA,UAAAA;AATG,KAAA;;AAYLI,IAAAA,MAAM,CAAA,UAAA,EAA4B;AAAA,UAAA,OAAA;;AAChCJ,MAAAA,KAAK,GAAGG,iCAAW,CAAA,KAAA,EAAnBH,UAAmB,CAAnBA;AACA,OAAA,OAAA,GAAA,KAAK,CAAL,CAAK,CAAL,MAAA,IAAA,IAAA,OAAA,KAAA,KAAA,CAAA,IAAA,OAAA,CAAA,MAAA,EAAA;AACD;;AAfI,GAAP;AAiBD;;AAED,SAAA,iCAAA,CAAA,KAAA,EAAA,IAAA,EAA6C;AAC3C,QAAMK,YAAY,GAAG,C,GAAA,KAAA,CAArB;AACA,QAAMC,KAAK,GAAGD,YAAY,CAAZA,OAAAA,CAAd,IAAcA,CAAd;AACA,MAAIC,KAAK,KAAK,CAAd,CAAA,EACED,YAAY,CAAZA,MAAAA,CAAAA,KAAAA,EAAAA,CAAAA;AAEF,SAAA,YAAA;AACD;;AAED,SAAA,iCAAA,CAAA,KAAA,EAA2C;AACzC,SAAO,KAAK,CAAL,MAAA,CAAa,IAACE,IAASA,IAAI,CAAJA,OAAAA,KAAvB,GAAA,CAAP;AACD;;AAED,MAAMC,yCAAI,GAAV,yCAAA","sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget as HTMLElement | null;\n\n        // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return;\n\n        // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations: MutationRecord[]) {\n        const focusedElement = document.activeElement as HTMLElement | null;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"]},"metadata":{},"sourceType":"script"}