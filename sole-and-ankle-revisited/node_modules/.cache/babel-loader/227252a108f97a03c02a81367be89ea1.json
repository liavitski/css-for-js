{"ast":null,"code":"var $dAvBt$babelruntimehelpersextends = require(\"@babel/runtime/helpers/extends\");\n\nvar $dAvBt$react = require(\"react\");\n\nvar $dAvBt$radixuireactcomposerefs = require(\"@radix-ui/react-compose-refs\");\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n$parcel$export(module.exports, \"Slot\", () => $82dc8d030dec7549$export$8c6ed5c666ac1360);\n$parcel$export(module.exports, \"Slottable\", () => $82dc8d030dec7549$export$d9f1ccf0bdb05d45);\n$parcel$export(module.exports, \"Root\", () => $82dc8d030dec7549$export$be92b6f5f03c0fe9);\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\nconst $82dc8d030dec7549$export$8c6ed5c666ac1360 = /*#__PURE__*/$dAvBt$react.forwardRef((props, forwardedRef) => {\n  const {\n    children: children,\n    ...slotProps\n  } = props;\n  const childrenArray = $dAvBt$react.Children.toArray(children);\n  const slottable = childrenArray.find($82dc8d030dec7549$var$isSlottable);\n\n  if (slottable) {\n    // the new element to render is the one passed as a child of `Slottable`\n    const newElement = slottable.props.children;\n    const newChildren = childrenArray.map(child => {\n      if (child === slottable) {\n        // because the new element will be the one rendered, we are only interested\n        // in grabbing its children (`newElement.props.children`)\n        if ($dAvBt$react.Children.count(newElement) > 1) return $dAvBt$react.Children.only(null);\n        return /*#__PURE__*/$dAvBt$react.isValidElement(newElement) ? newElement.props.children : null;\n      } else return child;\n    });\n    return /*#__PURE__*/$dAvBt$react.createElement($82dc8d030dec7549$var$SlotClone, $parcel$interopDefault($dAvBt$babelruntimehelpersextends)({}, slotProps, {\n      ref: forwardedRef\n    }), /*#__PURE__*/$dAvBt$react.isValidElement(newElement) ? /*#__PURE__*/$dAvBt$react.cloneElement(newElement, undefined, newChildren) : null);\n  }\n\n  return /*#__PURE__*/$dAvBt$react.createElement($82dc8d030dec7549$var$SlotClone, $parcel$interopDefault($dAvBt$babelruntimehelpersextends)({}, slotProps, {\n    ref: forwardedRef\n  }), children);\n});\n$82dc8d030dec7549$export$8c6ed5c666ac1360.displayName = 'Slot';\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\nconst $82dc8d030dec7549$var$SlotClone = /*#__PURE__*/$dAvBt$react.forwardRef((props, forwardedRef) => {\n  const {\n    children: children,\n    ...slotProps\n  } = props;\n  if ( /*#__PURE__*/$dAvBt$react.isValidElement(children)) return /*#__PURE__*/$dAvBt$react.cloneElement(children, { ...$82dc8d030dec7549$var$mergeProps(slotProps, children.props),\n    ref: forwardedRef ? $dAvBt$radixuireactcomposerefs.composeRefs(forwardedRef, children.ref) : children.ref\n  });\n  return $dAvBt$react.Children.count(children) > 1 ? $dAvBt$react.Children.only(null) : null;\n});\n$82dc8d030dec7549$var$SlotClone.displayName = 'SlotClone';\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst $82dc8d030dec7549$export$d9f1ccf0bdb05d45 = ({\n  children: children\n}) => {\n  return /*#__PURE__*/$dAvBt$react.createElement($dAvBt$react.Fragment, null, children);\n};\n/* ---------------------------------------------------------------------------------------------- */\n\n\nfunction $82dc8d030dec7549$var$isSlottable(child) {\n  return /*#__PURE__*/$dAvBt$react.isValidElement(child) && child.type === $82dc8d030dec7549$export$d9f1ccf0bdb05d45;\n}\n\nfunction $82dc8d030dec7549$var$mergeProps(slotProps, childProps) {\n  // all child props should override\n  const overrideProps = { ...childProps\n  };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) overrideProps[propName] = (...args) => {\n        childPropValue(...args);\n        slotPropValue(...args);\n      };else if (slotPropValue) overrideProps[propName] = slotPropValue;\n    } else if (propName === 'style') overrideProps[propName] = { ...slotPropValue,\n      ...childPropValue\n    };else if (propName === 'className') overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n  }\n\n  return { ...slotProps,\n    ...overrideProps\n  };\n}\n\nconst $82dc8d030dec7549$export$be92b6f5f03c0fe9 = $82dc8d030dec7549$export$8c6ed5c666ac1360;","map":{"version":3,"sources":["packages/react/slot/src/Slot.tsx"],"names":["Slot","childrenArray","React","slottable","newElement","newChildren","child","SlotClone","mergeProps","children","ref","forwardedRef","composeRefs","Slottable","overrideProps","slotPropValue","slotProps","childPropValue","childProps","isHandler","args","propName","Root"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = React.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n\n  if (slottable) {\n    // the new element to render is the one passed as a child of `Slottable`\n    const newElement = slottable.props.children as React.ReactNode;\n\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        // because the new element will be the one rendered, we are only interested\n        // in grabbing its children (`newElement.props.children`)\n        if (React.Children.count(newElement) > 1) return React.Children.only(null);\n        return React.isValidElement(newElement)\n          ? (newElement.props.children as React.ReactNode)\n          : null;\n      } else {\n        return child;\n      }\n    });\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {React.isValidElement(newElement)\n          ? React.cloneElement(newElement, undefined, newChildren)\n          : null}\n      </SlotClone>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      ref: forwardedRef ? composeRefs(forwardedRef, (children as any).ref) : (children as any).ref,\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          childPropValue(...args);\n          slotPropValue(...args);\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n"]},"metadata":{},"sourceType":"script"}