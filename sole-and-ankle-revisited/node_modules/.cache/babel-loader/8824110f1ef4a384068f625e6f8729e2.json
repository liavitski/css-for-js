{"ast":null,"code":"var $dAvBt$babelruntimehelpersextends = require(\"@babel/runtime/helpers/extends\");\nvar $dAvBt$react = require(\"react\");\nvar $dAvBt$radixuireactcomposerefs = require(\"@radix-ui/react-compose-refs\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n$parcel$export(module.exports, \"Slot\", () => $82dc8d030dec7549$export$8c6ed5c666ac1360);\n$parcel$export(module.exports, \"Slottable\", () => $82dc8d030dec7549$export$d9f1ccf0bdb05d45);\n$parcel$export(module.exports, \"Root\", () => $82dc8d030dec7549$export$be92b6f5f03c0fe9);\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\nconst $82dc8d030dec7549$export$8c6ed5c666ac1360 = /*#__PURE__*/$dAvBt$react.forwardRef((props, forwardedRef) => {\n  const {\n    children: children,\n    ...slotProps\n  } = props;\n  const childrenArray = $dAvBt$react.Children.toArray(children);\n  const slottable = childrenArray.find($82dc8d030dec7549$var$isSlottable);\n  if (slottable) {\n    // the new element to render is the one passed as a child of `Slottable`\n    const newElement = slottable.props.children;\n    const newChildren = childrenArray.map(child => {\n      if (child === slottable) {\n        // because the new element will be the one rendered, we are only interested\n        // in grabbing its children (`newElement.props.children`)\n        if ($dAvBt$react.Children.count(newElement) > 1) return $dAvBt$react.Children.only(null);\n        return /*#__PURE__*/$dAvBt$react.isValidElement(newElement) ? newElement.props.children : null;\n      } else return child;\n    });\n    return /*#__PURE__*/$dAvBt$react.createElement($82dc8d030dec7549$var$SlotClone, $parcel$interopDefault($dAvBt$babelruntimehelpersextends)({}, slotProps, {\n      ref: forwardedRef\n    }), /*#__PURE__*/$dAvBt$react.isValidElement(newElement) ? /*#__PURE__*/$dAvBt$react.cloneElement(newElement, undefined, newChildren) : null);\n  }\n  return /*#__PURE__*/$dAvBt$react.createElement($82dc8d030dec7549$var$SlotClone, $parcel$interopDefault($dAvBt$babelruntimehelpersextends)({}, slotProps, {\n    ref: forwardedRef\n  }), children);\n});\n$82dc8d030dec7549$export$8c6ed5c666ac1360.displayName = 'Slot';\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\nconst $82dc8d030dec7549$var$SlotClone = /*#__PURE__*/$dAvBt$react.forwardRef((props, forwardedRef) => {\n  const {\n    children: children,\n    ...slotProps\n  } = props;\n  if ( /*#__PURE__*/$dAvBt$react.isValidElement(children)) return /*#__PURE__*/$dAvBt$react.cloneElement(children, {\n    ...$82dc8d030dec7549$var$mergeProps(slotProps, children.props),\n    ref: forwardedRef ? $dAvBt$radixuireactcomposerefs.composeRefs(forwardedRef, children.ref) : children.ref\n  });\n  return $dAvBt$react.Children.count(children) > 1 ? $dAvBt$react.Children.only(null) : null;\n});\n$82dc8d030dec7549$var$SlotClone.displayName = 'SlotClone';\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\nconst $82dc8d030dec7549$export$d9f1ccf0bdb05d45 = ({\n  children: children\n}) => {\n  return /*#__PURE__*/$dAvBt$react.createElement($dAvBt$react.Fragment, null, children);\n};\n/* ---------------------------------------------------------------------------------------------- */\nfunction $82dc8d030dec7549$var$isSlottable(child) {\n  return /*#__PURE__*/$dAvBt$react.isValidElement(child) && child.type === $82dc8d030dec7549$export$d9f1ccf0bdb05d45;\n}\nfunction $82dc8d030dec7549$var$mergeProps(slotProps, childProps) {\n  // all child props should override\n  const overrideProps = {\n    ...childProps\n  };\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) overrideProps[propName] = (...args) => {\n        childPropValue(...args);\n        slotPropValue(...args);\n      };else if (slotPropValue) overrideProps[propName] = slotPropValue;\n    } else if (propName === 'style') overrideProps[propName] = {\n      ...slotPropValue,\n      ...childPropValue\n    };else if (propName === 'className') overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n  }\n  return {\n    ...slotProps,\n    ...overrideProps\n  };\n}\nconst $82dc8d030dec7549$export$be92b6f5f03c0fe9 = $82dc8d030dec7549$export$8c6ed5c666ac1360;","map":{"version":3,"names":["$82dc8d030dec7549$export$8c6ed5c666ac1360","$dAvBt$react","forwardRef","props","forwardedRef","children","slotProps","childrenArray","Children","toArray","slottable","find","$82dc8d030dec7549$var$isSlottable","newElement","newChildren","map","child","count","only","isValidElement","createElement","$82dc8d030dec7549$var$SlotClone","$parcel$interopDefault","$dAvBt$babelruntimehelpersextends","ref","cloneElement","undefined","displayName","$82dc8d030dec7549$var$mergeProps","$dAvBt$radixuireactcomposerefs","composeRefs","$82dc8d030dec7549$export$d9f1ccf0bdb05d45","Slottable","Fragment","isSlottable","type","mergeProps","childProps","overrideProps","propName","slotPropValue","childPropValue","isHandler","test","args","filter","Boolean","join","$82dc8d030dec7549$export$be92b6f5f03c0fe9"],"sources":["packages/react/slot/src/index.ts","packages/react/slot/src/Slot.tsx"],"sourcesContent":["export {\n  Slot,\n  Slottable,\n  //\n  Root,\n} from './Slot';\nexport type { SlotProps } from './Slot';\n","import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = React.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n\n  if (slottable) {\n    // the new element to render is the one passed as a child of `Slottable`\n    const newElement = slottable.props.children as React.ReactNode;\n\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        // because the new element will be the one rendered, we are only interested\n        // in grabbing its children (`newElement.props.children`)\n        if (React.Children.count(newElement) > 1) return React.Children.only(null);\n        return React.isValidElement(newElement)\n          ? (newElement.props.children as React.ReactNode)\n          : null;\n      } else {\n        return child;\n      }\n    });\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {React.isValidElement(newElement)\n          ? React.cloneElement(newElement, undefined, newChildren)\n          : null}\n      </SlotClone>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      ref: forwardedRef ? composeRefs(forwardedRef, (children as any).ref) : (children as any).ref,\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          childPropValue(...args);\n          slotPropValue(...args);\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}